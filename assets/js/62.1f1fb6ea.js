(window.webpackJsonp=window.webpackJsonp||[]).push([[62],{566:function(e,t,a){"use strict";a.r(t);var c=a(31),l=Object(c.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("div",{staticClass:"custom-block tip"},[a("p",[e._v("vue 异步更新机制")])]),e._v(" "),a("h1",{attrs:{id:"vue-的异步更新机制是如何实现的？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-的异步更新机制是如何实现的？"}},[e._v("#")]),e._v(" Vue 的异步更新机制是如何实现的？")]),e._v(" "),a("p",[e._v("Vue 的异步更新机制的核心是利用了浏览器的异步任务队列来实现的，首选微任务队列，宏任务队列次之。")]),e._v(" "),a("p",[e._v("当响应式数据更新后，会调用 dep.notify 方法，通知 dep 中收集的 watcher 去执行 update 方法，watcher.update 将 watcher 自己放入一个 watcher 队列（全局的 queue 数组）。")]),e._v(" "),a("p",[e._v("然后通过 nextTick 方法将一个刷新 watcher 队列的方法（flushSchedulerQueue）放入一个全局的 callbacks 数组中。")]),e._v(" "),a("p",[e._v("如果此时浏览器的异步任务队列中没有一个叫 flushCallbacks 的函数，则执行 timerFunc 函数，将 flushCallbacks 函数放入异步任务队列。如果异步任务队列中已经存在 flushCallbacks 函数，等待其执行完成以后再放入下一个 flushCallbacks 函数。")]),e._v(" "),a("p",[e._v("flushCallbacks 函数负责执行 callbacks 数组中的所有 flushSchedulerQueue 函数。")]),e._v(" "),a("p",[e._v("flushSchedulerQueue 函数负责刷新 watcher 队列，即执行 queue 数组中每一个 watcher 的 run 方法，从而进入更新阶段，比如执行组件更新函数或者执行用户 watch 的回调函数。")]),e._v(" "),a("p",[e._v("完整的执行过程其实就是今天源码阅读的过程。")]),e._v(" "),a("h1",{attrs:{id:"vue-的-nexttick-api-是如何实现的？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-的-nexttick-api-是如何实现的？"}},[e._v("#")]),e._v(" Vue 的 nextTick API 是如何实现的？")]),e._v(" "),a("p",[e._v("Vue.nextTick 或者 vm.$nextTick 的原理其实很简单，就做了两件事：")]),e._v(" "),a("ol",[a("li",[e._v("将传递的回调函数用 try catch 包裹然后放入 callbacks 数组")]),e._v(" "),a("li",[e._v("执行 timerFunc 函数，在浏览器的异步任务队列放入一个刷新 callbacks 数组的函数")])])])}),[],!1,null,null,null);t.default=l.exports}}]);