(window.webpackJsonp=window.webpackJsonp||[]).push([[61],{572:function(v,e,t){"use strict";t.r(e);var a=t(31),_=Object(a.a)({},(function(){var v=this,e=v.$createElement,t=v._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("div",{staticClass:"custom-block tip"},[t("p",[v._v("Vue 实例方法")])]),v._v(" "),t("h1",{attrs:{id:"vm-set-obj-key-val-做了什么？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vm-set-obj-key-val-做了什么？"}},[v._v("#")]),v._v(" vm.$set(obj, key, val) 做了什么？")]),v._v(" "),t("p",[v._v("vm.$set 用于向响应式对象添加一个新的 property，并确保这个新的 property 同样是响应式的，并触发视图更新。由于 Vue 无法探测对象新增属性或者通过索引为数组新增一个元素，比如：this.obj.newProperty = 'val'、this.arr[3] = 'val'。所以这才有了 vm.$set，它是 Vue.set 的别名。")]),v._v(" "),t("ul",[t("li",[v._v("为对象添加一个新的响应式数据：调用 defineReactive 方法为对象增加响应式数据，然后执行 dep.notify 进行依赖通知，更新视图")]),v._v(" "),t("li",[v._v("为数组添加一个新的响应式数据：通过 splice 方法实现")])]),v._v(" "),t("h1",{attrs:{id:"vm-delete-obj-key-做了什么？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vm-delete-obj-key-做了什么？"}},[v._v("#")]),v._v(" vm.$delete(obj, key) 做了什么？")]),v._v(" "),t("p",[v._v("vm.$delete 用于删除对象上的执行属性。如果对象是响应式的，切能确保能触发视图更新。该方法主要用于避开 Vue 不能检测属性被删除的情况。它是 Vue.delete 的别名。")]),v._v(" "),t("ul",[t("li",[v._v("删除数组指定下标的元素，内部通过 splice 方法来完成")]),v._v(" "),t("li",[v._v("删除对象上的指定属性，则是先通过 delete 运算符删除该属性，然后执行 dep.notify 进行依赖通知，更新视图")])]),v._v(" "),t("h1",{attrs:{id:"vm-watch-exporfn-callback-options-做了什么？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vm-watch-exporfn-callback-options-做了什么？"}},[v._v("#")]),v._v(" vm.$watch(expOrFn, callback, [options]) 做了什么？")]),v._v(" "),t("p",[v._v("vm.$watch 负责观察 Vue 实例上的一个表达式或者一个函数计算结果的变化。当其发生变化时，回调函数就会被执行，并为回调函数传递两个参数，第一个为更新后的新值，第二个为老值。")]),v._v(" "),t("p",[v._v("这里需要 注意 一点的是：如果观察的是一个对象，比如：数组，当你用数组方法，比如 push 为数组新增一个元素时，回调函数被触发时传递的新值和老值相同，因为它们指向同一个引用，所以在观察一个对象并切在回调函数中有新老值是否相等的判断时需要注意。")]),v._v(" "),t("p",[v._v("vm.$watch 的第一个参数只接收简单的响应式数据的键路径，对于更复杂的表达式建议使用函数作为第一个参数。\n至于 vm.$watch 的内部原理是：")]),v._v(" "),t("ul",[t("li",[v._v("设置 options.user = true，标志是一个用户 watcher")]),v._v(" "),t("li",[v._v("实例化一个 Watcher 实例，当检测到数据更新时，通过 watcher 去触发回调函数的执行，并传递新老值作为回调函数的参数")]),v._v(" "),t("li",[v._v("返回一个 unwatch 函数，用于取消观察")])]),v._v(" "),t("h1",{attrs:{id:"vm-on-event-callback-做了什么？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vm-on-event-callback-做了什么？"}},[v._v("#")]),v._v(" vm.$on(event, callback) 做了什么？")]),v._v(" "),t("p",[v._v("监听当前实例上的自定义事件，事件可由 vm.$emit 触发，回调函数会接收所有传入事件触发函数（vm.$emit）的额外参数。")]),v._v(" "),t("p",[v._v("vm.$on 的原理很简单，就是处理传递的 event 和 callback 两个参数，将注册的事件和回调函数以键值对的形式存储到 vm._event 对象中，vm._events = { eventName: [cb1, cb2, ...], ... }。")]),v._v(" "),t("h1",{attrs:{id:"vm-emit-eventname-args-做了什么？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vm-emit-eventname-args-做了什么？"}},[v._v("#")]),v._v(" vm.$emit(eventName, [...args]) 做了什么？")]),v._v(" "),t("p",[v._v("触发当前实例上的指定事件，附加参数都会传递给事件的回调函数。")]),v._v(" "),t("p",[v._v("其内部原理就是执行 vm._events[eventName] 中所有的回调函数。")]),v._v(" "),t("p",[v._v("备注：从 $on 和 $emit 的实现原理也能看出，组件的自定义事件其实是谁触发谁监听，因为组件自定义事件的处理内部用的就是 vm.$on、vm.$emit。")]),v._v(" "),t("h1",{attrs:{id:"vm-off-event-callback-做了什么？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vm-off-event-callback-做了什么？"}},[v._v("#")]),v._v(" vm.$off([event, callback]) 做了什么？")]),v._v(" "),t("p",[v._v("移除自定义事件监听器，即移除 vm._events 对象上相关数据。")]),v._v(" "),t("ul",[t("li",[v._v("如果没有提供参数，则移除实例的所有事件监听")]),v._v(" "),t("li",[v._v("如果只提供了 event 参数，则移除实例上该事件的所有监听器")]),v._v(" "),t("li",[v._v("如果两个参数都提供了，则移除实例上该事件对应的监听器")])]),v._v(" "),t("h1",{attrs:{id:"vm-once-event-callback-做了什么？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vm-once-event-callback-做了什么？"}},[v._v("#")]),v._v(" vm.$once(event, callback) 做了什么？")]),v._v(" "),t("p",[v._v("监听一个自定义事件，但是该事件只会被触发一次。一旦触发以后监听器就会被移除。")]),v._v(" "),t("p",[v._v("其内部的实现原理是：")]),v._v(" "),t("ul",[t("li",[v._v("包装用户传递的回调函数，当包装函数执行的时候，除了会执行用户回调函数之外还会执行 vm.$off(event, 包装函数) 移除该事件")]),v._v(" "),t("li",[v._v("用 vm.$on(event, 包装函数) 注册事件")])]),v._v(" "),t("h1",{attrs:{id:"vm-update-vnode-hydrating-做了什么？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vm-update-vnode-hydrating-做了什么？"}},[v._v("#")]),v._v(" vm._update(vnode, hydrating) 做了什么？")]),v._v(" "),t("p",[v._v("官方文档没有说明该 API，这是一个用于源码内部的实例方法，负责更新页面，是页面渲染的入口，其内部根据是否存在 prevVnode 来决定是首次渲染，还是页面更新，从而在调用 "),t("strong",[v._v("patch")]),v._v(" 函数时传递不同的参数。该方法在业务开发中不会用到。")]),v._v(" "),t("h1",{attrs:{id:"vm-forceupdate-做了什么？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vm-forceupdate-做了什么？"}},[v._v("#")]),v._v(" vm.$forceUpdate() 做了什么？")]),v._v(" "),t("p",[v._v("迫使 Vue 实例重新渲染，它仅仅影响组件实例本身和插入插槽内容的子组件，而不是所有子组件。其内部原理到也简单，就是直接调用 vm._watcher.update()，它就是 watcher.update() 方法，执行该方法触发组件更新。")]),v._v(" "),t("h1",{attrs:{id:"vm-destroy-做了什么？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vm-destroy-做了什么？"}},[v._v("#")]),v._v(" vm.$destroy() 做了什么？")]),v._v(" "),t("p",[v._v("负责完全销毁一个实例。清理它与其它实例的连接，解绑它的全部指令和事件监听器。在执行过程中会调用 beforeDestroy 和 destroy 两个钩子函数。在大多数业务开发场景下用不到该方法，一般都通过 v-if 指令来操作。")]),v._v(" "),t("p",[v._v("其内部原理是：")]),v._v(" "),t("ul",[t("li",[v._v("调用 beforeDestroy 钩子函数")]),v._v(" "),t("li",[v._v("将自己从老爹肚子里（$parent）移除，从而销毁和老爹的关系")]),v._v(" "),t("li",[v._v("通过 watcher.teardown() 来移除依赖监听")]),v._v(" "),t("li",[v._v("通过 vm."),t("strong",[v._v("patch")]),v._v("(vnode, null) 方法来销毁节点")]),v._v(" "),t("li",[v._v("调用 destroyed 钩子函数")]),v._v(" "),t("li",[v._v("通过 vm.$off 方法移除所有的事件监听")])]),v._v(" "),t("h1",{attrs:{id:"vm-nexttick-cb-做了什么？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vm-nexttick-cb-做了什么？"}},[v._v("#")]),v._v(" vm.$nextTick(cb) 做了什么？")]),v._v(" "),t("p",[v._v("m.$nextTick 是 Vue.nextTick 的别名，其作用是延迟回调函数 cb 的执行，一般用于 this.key = newVal 更改数据后，想立即获取更改过后的 DOM 数据")]),v._v(" "),t("p",[v._v("其内部的执行过程是：")]),v._v(" "),t("ul",[t("li",[v._v("触发依赖通知更新，将负责更新的 watcher 放入 watcher 队列")]),v._v(" "),t("li",[v._v("将刷新 watcher 队列的函数放到 callbacks 数组中")]),v._v(" "),t("li",[v._v("在浏览器的异步任务队列中放入一个刷新 callbacks 数组的函数")]),v._v(" "),t("li",[v._v("vm.$nextTick(cb) 来插队，将 cb 函数放入 callbacks 数组")]),v._v(" "),t("li",[v._v("待将来的某个时刻执行刷新 callbacks 数组的函数")]),v._v(" "),t("li",[v._v("然后执行 callbacks 数组中的众多函数，触发 watcher.run 的执行，更新 DOM")]),v._v(" "),t("li",[v._v("由于 cb 函数是在后面放到 callbacks 数组，所以这就保证了先完成的 DOM 更新，再执行 cb 函数")])]),v._v(" "),t("h1",{attrs:{id:"vm-render-做了什么？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vm-render-做了什么？"}},[v._v("#")]),v._v(" vm._render 做了什么？")]),v._v(" "),t("p",[v._v("官方文档没有提供该方法，它是一个用于源码内部的实例方法，负责生成 vnode。其关键代码就一行，执行 render 函数生成 vnode。不过其中加了大量的异常处理代码。")])])}),[],!1,null,null,null);e.default=_.exports}}]);